(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{509:function(_,v,t){"use strict";t.r(v);var a=t(16),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("有关计算机网络的一些笔记。")]),_._v(" "),t("h2",{attrs:{id:"_1-dns的查询方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-dns的查询方式"}},[_._v("#")]),_._v(" 1.DNS的查询方式")]),_._v(" "),t("p",[_._v("①递归查询\n②迭代查询")]),_._v(" "),t("p",[_._v("正向解析过程（域名解析为IP）")]),_._v(" "),t("p",[_._v("1）首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表；")]),_._v(" "),t("p",[_._v("2）若没有命中，则继续搜索操作系统的 DNS 缓存；")]),_._v(" "),t("p",[_._v("3）若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是"),t("strong",[_._v("递归查询")]),_._v("）；")]),_._v(" "),t("p",[_._v("4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行迭代查询（注意：本地域名服务器和其他域名服务器之间的查询方式是"),t("strong",[_._v("迭代查询")]),_._v("，防止根域名服务器压力过大）：")]),_._v(" "),t("p",[_._v("首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案\n本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址\n本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址")]),_._v(" "),t("p",[_._v("5）本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来")]),_._v(" "),t("p",[_._v("6）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来")]),_._v(" "),t("p",[_._v("7）至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来")]),_._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Stefancharles/images/dns.png",alt:""}})])]),t("h2",{attrs:{id:"_2-拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-拥塞控制"}},[_._v("#")]),_._v(" 2.拥塞控制")]),_._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Stefancharles/images/wangluoyongse.png",alt:""}})])]),t("h2",{attrs:{id:"_3-网络核心部分和边缘部分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-网络核心部分和边缘部分"}},[_._v("#")]),_._v(" 3.网络核心部分和边缘部分")]),_._v(" "),t("p",[_._v("边缘部分:由各主机构成，边缘部分利用核心部分提供的服务，使众多主机之间能够互相通信并交换信息或共享信息；")]),_._v(" "),t("p",[_._v("核心部分:网络中的核心部分由许多路由器实现互连，向网络边缘中的主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信。")]),_._v(" "),t("p",[_._v("核心部分中起特殊作用的是路由器（router）。它是一种专用计算机，用来转发收到的分组，这是核心部分最重要的功能。路由器是实现分组交换（packet switching）的关键构件。")]),_._v(" "),t("h2",{attrs:{id:"_4-tcp相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-tcp相关"}},[_._v("#")]),_._v(" 4.TCP相关")]),_._v(" "),t("h3",{attrs:{id:"_4-1tcp特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1tcp特性"}},[_._v("#")]),_._v(" 4.1TCP特性")]),_._v(" "),t("ul",[t("li",[_._v("TCP 提供一种面向连接的、可靠的字节流服务")]),_._v(" "),t("li",[_._v("在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP")]),_._v(" "),t("li",[_._v("TCP 使用校验和，确认和重传机制来保证可靠传输")]),_._v(" "),t("li",[_._v("TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复")]),_._v(" "),t("li",[_._v("TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制")])]),_._v(" "),t("blockquote",[t("p",[_._v("注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。")])]),_._v(" "),t("h3",{attrs:{id:"_4-2三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2三次握手"}},[_._v("#")]),_._v(" 4.2三次握手")]),_._v(" "),t("p",[_._v("所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。")]),_._v(" "),t("p",[_._v("三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。")]),_._v(" "),t("p",[_._v("① 第一次握手(SYN=1, seq=x):")]),_._v(" "),t("p",[_._v("客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。")]),_._v(" "),t("p",[_._v("发送完毕后，客户端进入 SYN_SEND 状态。")]),_._v(" "),t("p",[_._v("② 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):")]),_._v(" "),t("p",[_._v("服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。")]),_._v(" "),t("p",[_._v("③ 第三次握手(ACK=1，ACKnum=y+1)")]),_._v(" "),t("p",[_._v("客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1")]),_._v(" "),t("p",[_._v("发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。")]),_._v(" "),t("p",[_._v("三次握手的过程的示意图如下：")]),_._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Stefancharles/images@master/20211028/tcp-connection-made-three-way-handshake.10vpdc4n95io.png",alt:""}})])]),t("h3",{attrs:{id:"_4-3四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3四次挥手"}},[_._v("#")]),_._v(" 4.3四次挥手")]),_._v(" "),t("p",[_._v("TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。")]),_._v(" "),t("p",[_._v("① 第一次挥手(FIN=1，seq=x)")]),_._v(" "),t("p",[_._v("假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。")]),_._v(" "),t("p",[_._v("发送完毕后，客户端进入 FIN_WAIT_1 状态。")]),_._v(" "),t("p",[_._v("② 第二次挥手(ACK=1，ACKnum=x+1)")]),_._v(" "),t("p",[_._v("服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。")]),_._v(" "),t("p",[_._v("发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。")]),_._v(" "),t("p",[_._v("③ 第三次挥手(FIN=1，seq=y)")]),_._v(" "),t("p",[_._v("服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。")]),_._v(" "),t("p",[_._v("发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。")]),_._v(" "),t("p",[_._v("④ 第四次挥手(ACK=1，ACKnum=y+1)")]),_._v(" "),t("p",[_._v("客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。")]),_._v(" "),t("p",[_._v("服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。")]),_._v(" "),t("p",[_._v("客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。")]),_._v(" "),t("p",[_._v("四次挥手的示意图如下：")]),_._v(" "),t("div",{staticClass:"center-container"},[t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/Stefancharles/images@master/20211028/tcp-connection-closed-four-way-handshake.7g22urqpoc40.png",alt:""}})])]),t("h3",{attrs:{id:"_4-4syn攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4syn攻击"}},[_._v("#")]),_._v(" 4.4SYN攻击")]),_._v(" "),t("ul",[t("li",[_._v("什么是 SYN 攻击（SYN Flood）？")])]),_._v(" "),t("p",[_._v("在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.")]),_._v(" "),t("p",[_._v("SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。")]),_._v(" "),t("p",[_._v("SYN 攻击是一种典型的 DoS/DDoS 攻击。")]),_._v(" "),t("ul",[t("li",[_._v("如何检测 SYN 攻击？")])]),_._v(" "),t("p",[_._v("检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。")]),_._v(" "),t("ul",[t("li",[_._v("如何防御 SYN 攻击？")])]),_._v(" "),t("p",[_._v("SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：")]),_._v(" "),t("p",[_._v("缩短超时（SYN Timeout）时间")]),_._v(" "),t("p",[_._v("增加最大半连接数")]),_._v(" "),t("p",[_._v("过滤网关防护")]),_._v(" "),t("p",[_._v("SYN cookies技术")]),_._v(" "),t("h2",{attrs:{id:"_5-子网掩码和网络划分常见问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-子网掩码和网络划分常见问题"}},[_._v("#")]),_._v(" 5.子网掩码和网络划分常见问题")]),_._v(" "),t("h3",{attrs:{id:"_5-1-利用子网数来计算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-利用子网数来计算"}},[_._v("#")]),_._v(" 5.1 利用子网数来计算")]),_._v(" "),t("p",[_._v("假设欲将B类IP地址"),t("strong",[_._v("168.195.0.0")]),_._v("划分成27个子网")]),_._v(" "),t("ul",[t("li",[_._v("1.将子网数转换为二进制表达")])]),_._v(" "),t("p",[_._v("27 = 11011")]),_._v(" "),t("ul",[t("li",[_._v("2.取该二进制的长度N")])]),_._v(" "),t("p",[_._v("显然上面是N = 5")]),_._v(" "),t("ul",[t("li",[_._v("3.将主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码")])]),_._v(" "),t("p",[_._v("168.195.0.0 先把前面网络部分168.195置全1，也就是255.255")]),_._v(" "),t("p",[_._v("然后的0是主机地址前5位置1，11111000 = 248")]),_._v(" "),t("p",[_._v("最后子网掩码的结果就是 "),t("strong",[_._v("255.255.248.0")])]),_._v(" "),t("h3",{attrs:{id:"_5-2-利用主机数来计算"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-利用主机数来计算"}},[_._v("#")]),_._v(" 5.2 利用主机数来计算")]),_._v(" "),t("p",[_._v("假设欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台")]),_._v(" "),t("ul",[t("li",[_._v("1.将主机数转换为二进制表达")])]),_._v(" "),t("p",[_._v("700 = 10 1011 1100")]),_._v(" "),t("ul",[t("li",[_._v("2.取该二进制的长度N")])]),_._v(" "),t("p",[_._v("N = 10")]),_._v(" "),t("ul",[t("li",[_._v("3.全部置1，从右往左，把N位置0")])]),_._v(" "),t("p",[_._v("先有255.255.255.255，再把右边起的10位置0，也就是255.255.11111100.00000000")]),_._v(" "),t("p",[_._v("即子网掩码应该为： 255.255.252.0")]),_._v(" "),t("blockquote",[t("p",[_._v("注意：当主机数较少时可能有坑")])]),_._v(" "),t("p",[_._v("（1）例如一个子网有10台主机，那么对于这个子网需要的IP地址是 10＋1＋1＋1＝13。")]),_._v(" "),t("p",[_._v("加的第一个1是指这个网络连接时所需的"),t("strong",[_._v("网关地址")]),_._v("，接着的两个1分别是指网络地址和广播地址。")]),_._v(" "),t("p",[_._v("因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。")]),_._v(" "),t("p",[_._v("如果一个子网有14台主机，常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。")]),_._v(" "),t("p",[_._v("但因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。")])])}),[],!1,null,null,null);v.default=s.exports}}]);